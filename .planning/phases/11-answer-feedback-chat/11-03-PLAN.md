---
phase: 11-answer-feedback-chat
plan: 03
type: execute
wave: 2
depends_on: ["11-01", "11-02"]
files_modified:
  - web_frontend/src/components/module/FeedbackChat.tsx
  - web_frontend/src/api/assessments.ts
  - web_frontend/src/components/module/AnswerBox.tsx
  - web_frontend/src/hooks/useAutoSave.ts
  - web_api/routes/feedback.py
autonomous: false

must_haves:
  truths:
    - "After clicking Finish on a feedback-enabled question, a chat interface appears below the completed answer"
    - "The AI sends an initial feedback message streamed via SSE"
    - "Student can type a reply and have a multi-turn conversation"
    - "Feedback conversation is restored on return visit (no duplicate initial message)"
    - "Reopening an answer archives the old feedback session"
    - "Same component works in both lesson sections and test sections"
  artifacts:
    - path: "web_frontend/src/components/module/FeedbackChat.tsx"
      provides: "Post-answer feedback chat component"
      min_lines: 80
    - path: "web_frontend/src/api/assessments.ts"
      provides: "sendFeedbackMessage and getFeedbackHistory API functions"
      contains: "sendFeedbackMessage"
    - path: "web_frontend/src/components/module/AnswerBox.tsx"
      provides: "FeedbackChat integration in completed state"
      contains: "FeedbackChat"
  key_links:
    - from: "web_frontend/src/components/module/FeedbackChat.tsx"
      to: "/api/chat/feedback"
      via: "sendFeedbackMessage async generator"
      pattern: "sendFeedbackMessage"
    - from: "web_frontend/src/components/module/FeedbackChat.tsx"
      to: "/api/chat/feedback/history"
      via: "getFeedbackHistory on mount"
      pattern: "getFeedbackHistory"
    - from: "web_frontend/src/components/module/AnswerBox.tsx"
      to: "web_frontend/src/components/module/FeedbackChat.tsx"
      via: "conditional render when isCompleted && segment.feedback"
      pattern: "isCompleted.*feedback"
    - from: "web_frontend/src/components/module/AnswerBox.tsx"
      to: "/api/chat/feedback/archive"
      via: "archive feedback session on reopenAnswer"
      pattern: "archiveFeedbackSession"
---

<objective>
Create the FeedbackChat frontend component and integrate it into AnswerBox so students see an AI feedback conversation after completing a feedback-enabled question.

Purpose: Completes the user-facing feedback loop -- students get actionable AI feedback on their answers and can have a follow-up conversation.
Output: FeedbackChat component renders below completed answers, streams AI responses, supports multi-turn conversation, persists and restores on return.
</objective>

<execution_context>
@/home/penguin/.claude/get-shit-done/workflows/execute-plan.md
@/home/penguin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-answer-feedback-chat/11-RESEARCH.md
@.planning/phases/11-answer-feedback-chat/11-01-SUMMARY.md
@.planning/phases/11-answer-feedback-chat/11-02-SUMMARY.md
@web_frontend/src/components/module/AnswerBox.tsx
@web_frontend/src/components/module/NarrativeChatSection.tsx
@web_frontend/src/api/assessments.ts
@web_frontend/src/api/modules.ts
@web_frontend/src/hooks/useAutoSave.ts
@web_frontend/src/types/module.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: FeedbackChat component and API client functions</name>
  <files>
    web_frontend/src/components/module/FeedbackChat.tsx
    web_frontend/src/api/assessments.ts
    web_api/routes/feedback.py
  </files>
  <action>
**1a. Add feedback API functions to assessments.ts:**

Add three functions following the existing patterns in this file and `api/modules.ts`:

```typescript
/**
 * Send a feedback message and stream the response.
 * Follows the same SSE async generator pattern as sendMessage in modules.ts.
 */
export async function* sendFeedbackMessage(
  questionId: string,
  moduleSlug: string,
  answerText: string,
  message: string,
  isAuthenticated: boolean,
): AsyncGenerator<{ type: string; content?: string }> {
  const res = await fetchWithRefresh(`${API_BASE}/api/chat/feedback`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      ...getAuthHeaders(isAuthenticated),
    },
    credentials: "include",
    body: JSON.stringify({ questionId, moduleSlug, answerText, message }),
  });

  if (!res.ok) throw new Error("Failed to send feedback message");

  const reader = res.body?.getReader();
  if (!reader) throw new Error("No response body");

  const decoder = new TextDecoder();
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    const chunk = decoder.decode(value);
    const lines = chunk.split("\n");
    for (const line of lines) {
      if (!line.startsWith("data: ")) continue;
      try {
        yield JSON.parse(line.slice(6));
      } catch { /* skip invalid JSON */ }
    }
  }
}

/**
 * Fetch feedback chat history for a question.
 */
export async function getFeedbackHistory(
  questionId: string,
  isAuthenticated: boolean,
): Promise<{ sessionId: number; messages: Array<{ role: string; content: string }> }> {
  const res = await fetchWithRefresh(
    `${API_BASE}/api/chat/feedback/history?questionId=${encodeURIComponent(questionId)}`,
    {
      headers: { ...getAuthHeaders(isAuthenticated) },
      credentials: "include",
    },
  );
  if (!res.ok) {
    if (res.status === 401) return { sessionId: 0, messages: [] };
    throw new Error("Failed to fetch feedback history");
  }
  return res.json();
}

/**
 * Archive a feedback chat session (used when student reopens their answer).
 */
export async function archiveFeedbackSession(
  questionId: string,
  isAuthenticated: boolean,
): Promise<void> {
  await fetchWithRefresh(
    `${API_BASE}/api/chat/feedback/archive`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...getAuthHeaders(isAuthenticated),
      },
      credentials: "include",
      body: JSON.stringify({ questionId }),
    },
  );
  // Ignore errors -- archiving is best-effort (session may not exist)
}
```

**1b. Add archive endpoint to web_api/routes/feedback.py:**

Add a third endpoint to the feedback router (created in Plan 02):

POST /api/chat/feedback/archive -- Accepts `{questionId: str}`. Computes `content_id = uuid5(NAMESPACE_URL, questionId)`. Builds WHERE conditions matching the active session for this user/anonymous_token and content_id with content_type="feedback". If session found, calls `archive_chat_session(conn, session_id=session["session_id"])`. Returns `{"ok": true}` always (200, even if no session found -- archiving is best-effort).

**1c. Create FeedbackChat.tsx:**

A simpler, lighter component than NarrativeChatSection. No voice recording, no stage transitions, no scroll container management. Just a chat below the completed answer.

Props interface:
```typescript
interface FeedbackChatProps {
  questionId: string;       // e.g., "moduleSlug:0:2"
  moduleSlug: string;
  answerText: string;       // The student's completed answer
  isAuthenticated: boolean;
  autoTrigger: boolean;     // true on first completion in this session, false on return visits
}
```

**Component behavior:**

1. **On mount:** Call `getFeedbackHistory(questionId, isAuthenticated)`. If messages exist, set them as the conversation history (return visit -- do NOT auto-trigger). If no messages AND `autoTrigger` is true, send an empty initial message to trigger AI feedback (the backend handles the initial prompt construction).

2. **State:** `messages: Array<{role: string, content: string}>`, `streamingContent: string`, `isStreaming: boolean`, `input: string`, `isLoading: boolean` (for initial history load).

3. **Auto-trigger initial feedback:** When `autoTrigger=true` and history has zero messages, call `sendFeedbackMessage(questionId, moduleSlug, answerText, "", isAuthenticated)` -- empty message string signals the backend to generate initial feedback. Collect streamed chunks into `streamingContent`, then when done event arrives, push the full assistant message into `messages` and clear `streamingContent`.

4. **User replies:** Text input at bottom. On submit, push user message to `messages`, clear input, call `sendFeedbackMessage` with the user's message text, stream response as above.

5. **Rendering:** Use `ChatMarkdown` (extract from NarrativeChatSection or copy the component inline -- it's just ReactMarkdown with remark-gfm and compact styling). Show messages as a list with role-based styling:
   - Assistant messages: left-aligned, bg-stone-50 rounded padding
   - User messages: right-aligned, bg-blue-50 rounded padding
   - Streaming content: same as assistant but with a blinking cursor indicator

6. **Input area:** Simple single-line-expanding textarea (like NarrativeChatSection but simpler). Disabled while `isStreaming`. Submit on Enter (Shift+Enter for newline). "Send" button.

7. **Scroll into view:** After mount and initial feedback starts streaming, call `containerRef.current?.scrollIntoView({ behavior: 'smooth', block: 'start' })` with a small delay (100ms) so the browser has time to render.

8. **Visual treatment:** The entire FeedbackChat sits inside a container with a top border (border-t border-stone-200) and subtle header label "AI Feedback" in text-xs text-stone-400. This visually separates it from the completed answer above.

9. **No voice recording in v1** per research recommendation.
  </action>
  <verify>
Run `cd web_frontend && npm run build` to confirm TypeScript compiles.
Run `cd web_frontend && npm run lint` to confirm no lint errors.
Run `ruff check . && ruff format --check .` to confirm Python changes pass linting.
  </verify>
  <done>
FeedbackChat component renders a chat interface with message history, streaming AI responses, and text input for follow-up. API functions for sending feedback messages (SSE), loading history, and archiving sessions are in assessments.ts. Archive endpoint added to backend.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire FeedbackChat into AnswerBox with session lifecycle</name>
  <files>
    web_frontend/src/components/module/AnswerBox.tsx
    web_frontend/src/hooks/useAutoSave.ts
  </files>
  <action>
**2a. Add feedback session archival to useAutoSave reopenAnswer:**

In `useAutoSave.ts`, import `archiveFeedbackSession` from `@/api/assessments`. The `reopenAnswer` function needs to archive any existing feedback session when the student reopens their answer, because the old feedback references the previous answer text.

Add a `questionId` parameter to the hook options if not already available (it is -- check the `UseAutoSaveOptions`). In the `reopenAnswer` callback, after the existing reopen logic, call:
```typescript
archiveFeedbackSession(questionId, isAuthenticated).catch(() => {});
```
This is fire-and-forget -- errors are silently ignored since the archive is best-effort.

**2b. Integrate FeedbackChat into AnswerBox completed state:**

In `AnswerBox.tsx`:

1. Import `FeedbackChat` from `./FeedbackChat`.

2. Add a `useRef<boolean>` called `justCompletedRef` initialized to `false`. In the `handleFinish` function, set `justCompletedRef.current = true` before calling `markComplete()`. This tracks whether the completion happened in this session (for autoTrigger vs return visit).

3. In the completed state JSX (the `isCompleted` branch, after the "Completed" indicator and "Answer again" button div), add:
```tsx
{segment.feedback && (
  <FeedbackChat
    questionId={questionId}
    moduleSlug={moduleSlug}
    answerText={text}
    isAuthenticated={isAuthenticated}
    autoTrigger={justCompletedRef.current}
  />
)}
```

This renders FeedbackChat only when: (a) the answer is completed, AND (b) the question segment has `feedback: true`. The `autoTrigger` prop is true only when the student just completed the answer in the current session (not on return visits where the answer was already completed).

**Important details:**
- `justCompletedRef` uses useRef (not useState) to avoid re-renders. It persists across the component's lifetime but resets on remount (return visit = fresh mount = false).
- The FeedbackChat component handles the distinction between "auto-trigger initial feedback" and "just show existing conversation" via the autoTrigger prop and checking if history has messages on mount.
  </action>
  <verify>
Run `cd web_frontend && npm run build` to confirm TypeScript compiles clean.
Run `cd web_frontend && npm run lint` to confirm no lint errors.
  </verify>
  <done>
AnswerBox renders FeedbackChat below completed answers when `segment.feedback === true`. Auto-trigger sends initial AI feedback on first completion. Return visits restore existing conversation without re-triggering. Reopening an answer archives the stale feedback session. Same integration works for questions in both lesson and test sections.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete feedback chat flow end-to-end</name>
  <action>
Human verification of the complete Answer Feedback Chat flow: content pipeline feedback field, backend streaming endpoint, FeedbackChat component, AnswerBox integration with session lifecycle.
  </action>
  <verify>
1. Add `feedback:: true` to a question segment in test content markdown (e.g., in a learning outcome file, add the field to an existing `#### Question` block)
2. Start dev servers: backend (`python main.py --dev --port 8300`) and frontend (`cd web_frontend && npm run dev`)
3. Navigate to a module containing the feedback-enabled question at http://dev.vps:3300
4. Type an answer and click "Finish"
5. Verify: A chat interface labeled "AI Feedback" appears below the completed answer
6. Verify: The AI sends an initial feedback message (streamed, not all at once)
7. Type a follow-up question and press Enter or click Send
8. Verify: The AI responds to the follow-up in context
9. Refresh the page
10. Verify: The completed answer shows with the existing conversation restored (no duplicate initial message)
11. Click "Answer again"
12. Verify: The feedback chat disappears (answer reopens for editing)
13. Type a new answer and click "Finish"
14. Verify: A fresh feedback conversation starts (old conversation was archived)
  </verify>
  <done>
Full feedback flow confirmed working: initial feedback on completion, multi-turn conversation, session persistence on refresh, session archival on reopen.
  </done>
</task>

</tasks>

<verification>
1. FeedbackChat renders below completed answer only when segment.feedback is true
2. Initial AI feedback is streamed via SSE on first completion
3. Multi-turn conversation works (user sends follow-up, AI responds in context)
4. Return visit restores conversation without duplicating initial message
5. Reopening answer archives old feedback session
6. Component works identically in lesson sections and test sections
7. Anonymous users can use feedback chat (X-Anonymous-Token passed)
8. Build and lint pass clean
</verification>

<success_criteria>
- FeedbackChat.tsx component handles loading, streaming, multi-turn, and empty states
- sendFeedbackMessage, getFeedbackHistory, archiveFeedbackSession in assessments.ts
- AnswerBox conditionally renders FeedbackChat for feedback-enabled completed answers
- autoTrigger distinguishes first completion from return visit
- reopenAnswer archives stale feedback session
- Human verification confirms full flow works
</success_criteria>

<output>
After completion, create `.planning/phases/11-answer-feedback-chat/11-03-SUMMARY.md`
</output>
