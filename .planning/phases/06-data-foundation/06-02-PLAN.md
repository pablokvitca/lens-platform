---
phase: 06-data-foundation
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - content_processor/src/content-schema.ts
  - content_processor/src/parser/sections.ts
  - content_processor/src/parser/lens.ts
  - content_processor/src/parser/learning-outcome.ts
  - content_processor/src/index.ts
  - content_processor/src/flattener/index.ts
  - web_api/routes/assessments.py
  - main.py
autonomous: true

must_haves:
  truths:
    - "Backend parses #### Question blocks from Obsidian content and returns them as 'question' segments in the module API response"
    - "Backend parses ## Test: sections from Learning Outcome files and includes test questions in the flattened module output as a 'test' section type"
    - "Obsidian %% comments %% are stripped during parsing so they don't appear in output"
    - "API endpoint accepts assessment response submissions and stores them in the database"
    - "API endpoint returns assessment responses for the current user, filterable by module and question"
    - "Existing module content (lessons, articles, videos, chat) continues to work unchanged"
  artifacts:
    - path: "content_processor/src/content-schema.ts"
      provides: "Question segment type schema definition"
      contains: "question"
    - path: "content_processor/src/parser/lens.ts"
      provides: "Question segment parsing in #### headers"
      contains: "question"
    - path: "content_processor/src/flattener/index.ts"
      provides: "Test section flattening and question segment conversion"
      contains: "question"
    - path: "content_processor/src/index.ts"
      provides: "QuestionSegment type definition and test section type"
      contains: "QuestionSegment"
    - path: "web_api/routes/assessments.py"
      provides: "Assessment API endpoints"
      exports: ["router"]
    - path: "main.py"
      provides: "Assessment router registration"
      contains: "assessments_router"
  key_links:
    - from: "web_api/routes/assessments.py"
      to: "core/assessments.py"
      via: "imports submit_response, get_responses"
      pattern: "from core.assessments import"
    - from: "web_api/routes/assessments.py"
      to: "web_api/auth.py"
      via: "get_user_or_anonymous dependency"
      pattern: "from web_api.auth import get_user_or_anonymous"
    - from: "content_processor/src/flattener/index.ts"
      to: "content_processor/src/index.ts"
      via: "imports QuestionSegment type"
      pattern: "QuestionSegment"
    - from: "main.py"
      to: "web_api/routes/assessments.py"
      via: "include_router"
      pattern: "app.include_router.*assessments"
---

<objective>
Add content parsing for Question blocks and Test sections, plus API endpoints for assessment data.

Purpose: This plan makes the content processor understand the new `#### Question` segment type and `## Test:` sections in Learning Outcome files, and creates the API endpoints that the frontend (Phase 7+) will use to submit and retrieve student answers.
Output: Extended content processor with question/test support, comment stripping, and new assessment API routes.
</objective>

<execution_context>
@/home/penguin/.claude/get-shit-done/workflows/execute-plan.md
@/home/penguin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-data-foundation/06-CONTEXT.md
@.planning/phases/06-data-foundation/06-RESEARCH.md
@.planning/phases/06-data-foundation/06-01-SUMMARY.md
@content_processor/src/content-schema.ts
@content_processor/src/parser/lens.ts
@content_processor/src/parser/sections.ts
@content_processor/src/parser/learning-outcome.ts
@content_processor/src/flattener/index.ts
@content_processor/src/index.ts
@web_api/routes/progress.py
@web_api/auth.py
@main.py
@core/assessments.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend content processor to parse Question segments, Test sections, and strip Obsidian comments</name>
  <files>
    content_processor/src/content-schema.ts
    content_processor/src/parser/sections.ts
    content_processor/src/parser/lens.ts
    content_processor/src/parser/learning-outcome.ts
    content_processor/src/index.ts
    content_processor/src/flattener/index.ts
  </files>
  <action>
This task extends the TypeScript content processor to understand `#### Question` blocks and `## Test:` sections. All changes are additive — existing segment/section types must remain unchanged.

**A. Add Obsidian comment stripping utility**

Before any parsing, `%% comment %%` syntax must be stripped. Create a preprocessing function (can be a simple helper in `content_processor/src/parser/` or inline where needed):
```typescript
function stripObsidianComments(content: string): string {
  // Strip inline comments: %% ... %% (single line)
  // Strip block comments: %% ... %% (multiline)
  return content.replace(/%%.*?%%/gs, '');
}
```
Apply this in the `parseLens` function (lens.ts) and `parseLearningOutcome` (learning-outcome.ts) BEFORE parsing frontmatter/sections — strip from the raw content string early. This ensures comments inside `user-instruction::`, `assessment-prompt::`, etc. don't leak into output.

**B. Add `question` segment type to content-schema.ts**

Add to `SEGMENT_SCHEMAS`:
```typescript
'question': segmentSchema(
  ['user-instruction'],  // required: the prompt shown to student
  ['assessment-prompt', 'max-time', 'max-chars', 'enforce-voice', 'optional'],
  ['enforce-voice', 'optional'],  // boolean fields
),
```

**C. Register `question` as valid segment type in lens.ts**

In `lens.ts`, update `LENS_SEGMENT_TYPES` to include `'question'`:
```typescript
const LENS_SEGMENT_TYPES = new Set(['text', 'chat', 'article-excerpt', 'video-excerpt', 'question']);
```

Update `VALID_SEGMENTS_PER_SECTION` to allow `question` in all section types:
```typescript
'page': new Set(['text', 'chat', 'question']),
'lens-article': new Set(['text', 'chat', 'article-excerpt', 'question']),
'lens-video': new Set(['text', 'chat', 'video-excerpt', 'question']),
```

Add a new case in the `convertSegment` function in `lens.ts` for `'question'` type:
```typescript
case 'question': {
  const userInstruction = raw.fields['user-instruction'];
  if (!userInstruction || userInstruction.trim() === '') {
    errors.push({
      file,
      line: raw.line,
      message: 'Question segment missing user-instruction:: field',
      suggestion: "Add 'user-instruction:: Your question here'",
      severity: 'error',
    });
    return { segment: null, errors };
  }

  const segment: ParsedQuestionSegment = {
    type: 'question',
    userInstruction,
    assessmentPrompt: raw.fields['assessment-prompt'] || undefined,
    maxTime: raw.fields['max-time'] || undefined,
    maxChars: raw.fields['max-chars'] ? parseInt(raw.fields['max-chars'], 10) : undefined,
    enforceVoice: raw.fields['enforce-voice']?.toLowerCase() === 'true' ? true : undefined,
    optional: raw.fields.optional?.toLowerCase() === 'true' ? true : undefined,
  };
  return { segment, errors };
}
```

Add the `ParsedQuestionSegment` interface to `lens.ts`:
```typescript
export interface ParsedQuestionSegment {
  type: 'question';
  userInstruction: string;
  assessmentPrompt?: string;
  maxTime?: string;        // e.g., "3:00" or "none"
  maxChars?: number;
  enforceVoice?: boolean;
  optional?: boolean;
}
```

Update `ParsedLensSegment` union type to include `ParsedQuestionSegment`.

**D. Add `QuestionSegment` to flattened output types in index.ts**

Add a new segment type interface in `content_processor/src/index.ts`:
```typescript
export interface QuestionSegment {
  type: 'question';
  userInstruction: string;
  assessmentPrompt?: string;
  maxTime?: string;
  maxChars?: number;
  enforceVoice?: boolean;
  optional?: boolean;
}
```

Update the `Segment` union type:
```typescript
export type Segment = TextSegment | ChatSegment | ArticleExcerptSegment | VideoExcerptSegment | QuestionSegment;
```

**E. Add `test` as a section type in the flattened output**

Update the `Section` interface `type` field in `content_processor/src/index.ts`:
```typescript
type: 'page' | 'lens-video' | 'lens-article' | 'test';
```

**F. Handle `question` segments in the flattener (flattener/index.ts)**

In the `convertSegment` function in `flattener/index.ts`, add a case for `'question'`:
```typescript
case 'question': {
  const segment: QuestionSegment = {
    type: 'question',
    userInstruction: parsedSegment.userInstruction,
  };
  if (parsedSegment.assessmentPrompt) segment.assessmentPrompt = parsedSegment.assessmentPrompt;
  if (parsedSegment.maxTime) segment.maxTime = parsedSegment.maxTime;
  if (parsedSegment.maxChars !== undefined) segment.maxChars = parsedSegment.maxChars;
  if (parsedSegment.enforceVoice) segment.enforceVoice = true;
  if (parsedSegment.optional) segment.optional = true;
  return { segment, errors };
}
```

Import `QuestionSegment` type from `'../index.js'` and `ParsedQuestionSegment` from `'../parser/lens.js'`.

**G. Parse ## Test: sections in Learning Outcomes and flatten them**

The LO parser (`learning-outcome.ts`) already recognizes `## Test:` sections (`LO_SECTION_TYPES` includes `'test'`). Currently it only extracts a `source::` wikilink reference. Extend it to also parse inline content when the Test section contains `#### Question`, `#### Chat`, `#### Text` blocks directly (no external file reference needed).

In `parseLearningOutcome`, when processing a `'test'` section:
- If the section has a `source::` field, keep existing behavior (external file reference)
- Additionally, parse the section body for H4 segments (#### Question, #### Chat, #### Text) using the same `parseSegments` function from lens.ts. Store these as `testSegments` on the `ParsedTestRef`.

Update `ParsedTestRef`:
```typescript
export interface ParsedTestRef {
  source?: string;           // Optional external file reference
  resolvedPath?: string;     // Resolved path if source provided
  segments: ParsedLensSegment[];  // Inline question/chat/text segments
}
```

In the flattener (`flattenLearningOutcomeSection` in `flattener/index.ts`), after processing all lens sections for an LO, check if the LO has a test section with segments. If it does, create a new `Section` with `type: 'test'`:
```typescript
// After lens processing loop, add test section if present
if (lo.test && lo.test.segments.length > 0) {
  const testSegments: Segment[] = [];
  for (const parsedSegment of lo.test.segments) {
    const segmentResult = convertSegment(/* ... */);
    // ... error handling ...
    if (segmentResult.segment) testSegments.push(segmentResult.segment);
  }

  if (testSegments.length > 0) {
    sections.push({
      type: 'test',
      meta: { title: 'Test' },
      segments: testSegments,
      optional: false,
      contentId: null,
      learningOutcomeId: lo.id ?? null,
      learningOutcomeName: loPath.split('/').pop()?.replace(/\.md$/i, '') ?? null,
      videoId: null,
    });
  }
}
```

Note: The `convertSegment` function in the flattener currently requires a `lensSection` and `lensPath` for article/video excerpt resolution. For test sections with only question/chat/text segments (no excerpt types), this is fine — those segment types don't need source file resolution. Pass a minimal stub for lensSection if needed.

**H. Backward compatibility**

Verify: Existing tests still pass after all changes. Run:
```bash
cd content_processor && npx vitest run
```

All changes are additive. Existing `text`, `chat`, `article-excerpt`, `video-excerpt` segment types and `page`, `lens-video`, `lens-article` section types remain unchanged.
  </action>
  <verify>
1. `cd /home/penguin/code/lens-platform/ws3/content_processor && npx vitest run` — all existing tests pass
2. `npx tsc --noEmit` in content_processor — no type errors
3. The `SEGMENT_SCHEMAS` in content-schema.ts includes a `'question'` entry
4. The `Segment` union type in index.ts includes `QuestionSegment`
5. The `Section` type field allows `'test'`
  </verify>
  <done>
Content processor parses #### Question segments with user-instruction, assessment-prompt, max-time, max-chars, enforce-voice fields. ## Test: sections in Learning Outcomes produce 'test' sections with question/chat/text segments. Obsidian %% comments %% stripped before parsing. All existing content types continue working unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create assessment API endpoints and register router</name>
  <files>web_api/routes/assessments.py, main.py</files>
  <action>
Create `web_api/routes/assessments.py` with API endpoints for submitting and retrieving assessment data. Follow the patterns from `web_api/routes/progress.py` — Pydantic models for request/response, `get_user_or_anonymous` dependency for auth, `get_transaction`/`get_connection` for DB access.

**Route file: `web_api/routes/assessments.py`**

```python
"""Assessment API routes.

Endpoints:
- POST /api/assessments/responses - Submit a student answer
- GET /api/assessments/responses - Get responses for current user
- GET /api/assessments/responses/{question_id} - Get responses for a specific question
"""
```

Router: `router = APIRouter(prefix="/api/assessments", tags=["assessments"])`

**Endpoint 1: POST /api/assessments/responses**
- Auth: `get_user_or_anonymous` (supports both JWT and anonymous token)
- Request body (Pydantic model `SubmitResponseRequest`):
  - `question_id: str` (required)
  - `module_slug: str` (required)
  - `learning_outcome_id: str | None = None`
  - `content_id: UUID | None = None`
  - `answer_text: str` (required)
  - `answer_metadata: dict = {}` (optional, for voice-used flag, time taken, etc.)
- Validation: `answer_text` must be non-empty (strip whitespace, check length > 0)
- Calls `core.assessments.submit_response` inside `get_transaction()`
- Response (Pydantic model `SubmitResponseResponse`):
  - `response_id: int`
  - `created_at: str` (ISO format)
- Returns 201 on success

**Endpoint 2: GET /api/assessments/responses**
- Auth: `get_user_or_anonymous`
- Query params: `module_slug: str | None = None`, `question_id: str | None = None`
- Calls `core.assessments.get_responses` inside `get_connection()`
- Response (Pydantic model `ResponseListResponse`):
  - `responses: list[ResponseItem]`
- `ResponseItem`:
  - `response_id: int`
  - `question_id: str`
  - `module_slug: str`
  - `learning_outcome_id: str | None`
  - `answer_text: str`
  - `answer_metadata: dict`
  - `created_at: str` (ISO format)

**Endpoint 3: GET /api/assessments/responses/{question_id}**
- Auth: `get_user_or_anonymous`
- Path param: `question_id: str`
- Calls `core.assessments.get_responses_for_question` inside `get_connection()`
- Same response shape as endpoint 2

Import style follows progress.py pattern:
```python
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from core.assessments import submit_response, get_responses, get_responses_for_question
from core.database import get_connection, get_transaction
from web_api.auth import get_user_or_anonymous
```

**Register router in main.py:**

Add import near the other route imports:
```python
from web_api.routes.assessments import router as assessments_router
```

Add `app.include_router(assessments_router)` after the existing `app.include_router(progress_router)` line.
  </action>
  <verify>
1. `ruff check web_api/routes/assessments.py` passes
2. `ruff check main.py` passes
3. `python -c "from web_api.routes.assessments import router; print(f'Routes: {len(router.routes)}')"` prints "Routes: 3"
4. Start the dev server with `--no-db --no-bot` and verify the routes appear: `curl http://localhost:8300/openapi.json | python -m json.tool | grep assessments` shows the three endpoints
  </verify>
  <done>
Three assessment API endpoints exist: POST /api/assessments/responses (submit answer), GET /api/assessments/responses (list responses with filters), GET /api/assessments/responses/{question_id} (responses for specific question). Router registered in main.py. All endpoints use dual auth (JWT + anonymous token) following existing patterns.
  </done>
</task>

</tasks>

<verification>
1. All existing content processor tests pass: `cd content_processor && npx vitest run`
2. All Python linting passes: `ruff check .` and `ruff format --check .`
3. TypeScript compiles without errors: `cd content_processor && npx tsc --noEmit`
4. Assessment API routes are registered and visible in OpenAPI schema
5. Module content API still returns existing content types unchanged (backward compatible)
6. Content processor produces QuestionSegment in output when #### Question blocks are present
7. Content processor produces 'test' section type when ## Test: sections contain question blocks
</verification>

<success_criteria>
- Content processor recognizes #### Question segments with user-instruction (required), assessment-prompt, max-time, max-chars, enforce-voice (optional)
- Content processor creates 'test' section type from ## Test: sections in Learning Outcomes
- Obsidian %% comments %% are stripped from parsed content
- POST /api/assessments/responses accepts and stores student answers
- GET /api/assessments/responses returns responses for current user with optional filters
- GET /api/assessments/responses/{question_id} returns responses for a specific question
- All existing content (lessons, articles, videos, chat) continues working unchanged
- Existing test suites pass without modification
</success_criteria>

<output>
After completion, create `.planning/phases/06-data-foundation/06-02-SUMMARY.md`
</output>
