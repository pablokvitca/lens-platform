---
phase: 05-motion-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - web_frontend/src/styles/globals.css
  - web_frontend/src/components/Skeleton.tsx
  - web_frontend/src/hooks/useViewTransition.ts
  - web_frontend/src/components/nav/BottomNav.tsx
  - web_frontend/src/views/Module.tsx
  - web_frontend/src/views/CourseOverview.tsx
autonomous: true

must_haves:
  truths:
    - "Page transitions use View Transitions API (content morphs, not instant cuts)"
    - "Loading states show skeleton placeholders instead of text"
    - "Skeletons pulse with subtle animation"
  artifacts:
    - path: "web_frontend/src/components/Skeleton.tsx"
      provides: "Reusable skeleton component with variants"
      exports: ["Skeleton"]
      min_lines: 20
    - path: "web_frontend/src/hooks/useViewTransition.ts"
      provides: "Hook for View Transitions API navigation"
      exports: ["useViewTransition"]
      min_lines: 15
    - path: "web_frontend/src/styles/globals.css"
      provides: "View transition CSS and skeleton animation"
      contains: "view-transition"
  key_links:
    - from: "BottomNav.tsx"
      to: "useViewTransition.ts"
      via: "hook import and usage"
      pattern: "useViewTransition"
    - from: "Module.tsx"
      to: "Skeleton.tsx"
      via: "component import for loading state"
      pattern: "Skeleton"
---

<objective>
Add View Transitions API for smooth page navigation and skeleton loading states.

Purpose: Page changes feel connected rather than jarring; loading states show content structure
Output: Navigation animates with crossfade/slide, loading areas show pulsing skeletons
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-motion-polish/05-CONTEXT.md
@.planning/phases/05-motion-polish/05-RESEARCH.md
@web_frontend/src/styles/globals.css
@web_frontend/src/components/nav/BottomNav.tsx
@web_frontend/src/views/Module.tsx
@web_frontend/src/views/CourseOverview.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Skeleton component and loading state utilities</name>
  <files>web_frontend/src/components/Skeleton.tsx, web_frontend/src/styles/globals.css</files>
  <action>
**Create Skeleton.tsx:**
Create a reusable skeleton component with variants:

```tsx
import { cn } from "@/lib/utils";

interface SkeletonProps {
  className?: string;
  variant?: "text" | "circular" | "rectangular";
}

/**
 * Skeleton placeholder component for loading states.
 * Shows pulsing placeholder matching content structure.
 */
export function Skeleton({ className, variant = "text" }: SkeletonProps) {
  const baseClasses = "animate-pulse bg-slate-200 rounded";

  const variantClasses = {
    text: "h-4 w-full",
    circular: "rounded-full",
    rectangular: "rounded-md",
  };

  return (
    <div
      className={cn(baseClasses, variantClasses[variant], className)}
      aria-hidden="true"
    />
  );
}

/**
 * Skeleton group for content sections.
 * Shows multiple lines to approximate text blocks.
 */
export function SkeletonText({ lines = 3, className }: { lines?: number; className?: string }) {
  return (
    <div className={cn("space-y-3", className)}>
      {Array.from({ length: lines }).map((_, i) => (
        <Skeleton
          key={i}
          className={cn("h-4", i === lines - 1 ? "w-3/4" : "w-full")}
        />
      ))}
    </div>
  );
}
```

Note: If `@/lib/utils` with `cn` doesn't exist, use this inline:
```tsx
const cn = (...classes: (string | undefined | false)[]) =>
  classes.filter(Boolean).join(" ");
```

**Update globals.css:**
Tailwind v4 already includes `animate-pulse` via @tailwindcss, but add skeleton-specific keyframes for staggered reveals:

```css
/* Staggered reveal animation for list items */
@keyframes stagger-in {
  from {
    opacity: 0;
    transform: translateY(8px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.stagger-item {
  animation: stagger-in 0.3s ease-out forwards;
  opacity: 0;
}

/* Stagger delay classes */
.stagger-delay-1 { animation-delay: 50ms; }
.stagger-delay-2 { animation-delay: 100ms; }
.stagger-delay-3 { animation-delay: 150ms; }
.stagger-delay-4 { animation-delay: 200ms; }
.stagger-delay-5 { animation-delay: 250ms; }
```
  </action>
  <verify>
1. Verify Skeleton.tsx exports Skeleton and SkeletonText
2. Verify globals.css contains stagger-in keyframes and .stagger-item class
3. Run `npm run build` in web_frontend to verify no TypeScript errors
  </verify>
  <done>Skeleton components created and stagger animation available</done>
</task>

<task type="auto">
  <name>Task 2: Implement View Transitions API for page navigation</name>
  <files>web_frontend/src/hooks/useViewTransition.ts, web_frontend/src/components/nav/BottomNav.tsx, web_frontend/src/styles/globals.css</files>
  <action>
**Create useViewTransition.ts:**
Create a hook that wraps navigation with View Transitions API:

```typescript
import { useCallback } from "react";
import { navigate } from "vike/client/router";

/**
 * Hook for navigating with View Transitions API.
 * Falls back to regular navigation if API not supported.
 */
export function useViewTransition() {
  const navigateWithTransition = useCallback(async (href: string) => {
    // Check if View Transitions API is supported
    if (!document.startViewTransition) {
      // Fallback: use regular Vike navigation
      await navigate(href);
      return;
    }

    // Use View Transitions API
    document.startViewTransition(async () => {
      await navigate(href);
    });
  }, []);

  return { navigateWithTransition };
}
```

**Update BottomNav.tsx:**
Replace anchor href navigation with view transition navigation:

1. Import the hook: `import { useViewTransition } from "@/hooks/useViewTransition";`
2. In NavItem, change from `<a href={href}>` to click handler:

```tsx
function NavItem({ href, icon, label, isActive }: NavItemProps) {
  const { navigateWithTransition } = useViewTransition();

  const handleClick = (e: React.MouseEvent) => {
    e.preventDefault();
    navigateWithTransition(href);
  };

  return (
    <a
      href={href}
      onClick={handleClick}
      className={`...existing classes...`}
    >
      {icon}
      <span className="text-xs font-medium">{label}</span>
    </a>
  );
}
```

**Update globals.css:**
Add View Transitions CSS for crossfade effect:

```css
/* View Transitions API styles */
@view-transition {
  navigation: auto;
}

::view-transition-old(root),
::view-transition-new(root) {
  animation-duration: 200ms;
}

/* Crossfade: old fades out, new fades in */
::view-transition-old(root) {
  animation: fade-out 200ms ease-out;
}

::view-transition-new(root) {
  animation: fade-in 200ms ease-in;
}

@keyframes fade-out {
  from { opacity: 1; }
  to { opacity: 0; }
}

@keyframes fade-in {
  from { opacity: 0; }
  to { opacity: 1; }
}
```
  </action>
  <verify>
1. Verify useViewTransition.ts exports the hook
2. Open app in mobile view, tap between Home and Course in BottomNav
3. Confirm page transition has crossfade effect (not instant cut)
4. Confirm fallback works in browsers without View Transitions API (Safari < 18)
5. Run `npm run build` to verify no TypeScript errors
  </verify>
  <done>Page transitions use View Transitions API with graceful fallback</done>
</task>

<task type="auto">
  <name>Task 3: Replace text loading states with skeletons</name>
  <files>web_frontend/src/views/Module.tsx, web_frontend/src/views/CourseOverview.tsx</files>
  <action>
Replace basic "Loading..." text with skeleton components:

**Module.tsx:**
Find the loading state (around line 701-705):
```tsx
if (loadingModule) {
  return (
    <div className="flex items-center justify-center h-screen">
      <p className="text-gray-500">Loading module...</p>
    </div>
  );
}
```

Replace with skeleton layout that mirrors actual content structure:
```tsx
if (loadingModule) {
  return (
    <div className="min-h-dvh bg-stone-50 p-4 sm:p-6">
      {/* Module header skeleton */}
      <div className="mb-6">
        <Skeleton className="h-8 w-48 mb-2" />
        <Skeleton className="h-4 w-32" />
      </div>
      {/* Content skeleton */}
      <div className="max-w-2xl">
        <SkeletonText lines={4} className="mb-6" />
        <Skeleton className="h-48 w-full rounded-lg mb-6" variant="rectangular" />
        <SkeletonText lines={3} />
      </div>
    </div>
  );
}
```

Add import at top: `import { Skeleton, SkeletonText } from "@/components/Skeleton";`

**CourseOverview.tsx:**
Find the loading state (around line 116-119):
```tsx
if (loading) {
  return (
    <div className="flex items-center justify-center h-64">
      <div className="text-slate-500">Loading course...</div>
    </div>
  );
}
```

Replace with skeleton that mirrors course card layout:
```tsx
if (loading) {
  return (
    <div className="p-4 sm:p-6">
      {/* Course title skeleton */}
      <Skeleton className="h-8 w-64 mb-6" />
      {/* Module cards skeleton */}
      <div className="space-y-4">
        {[1, 2, 3].map((i) => (
          <div key={i} className="p-4 border border-slate-200 rounded-lg">
            <Skeleton className="h-6 w-48 mb-2" />
            <Skeleton className="h-4 w-full mb-1" />
            <Skeleton className="h-4 w-3/4" />
          </div>
        ))}
      </div>
    </div>
  );
}
```

Add import at top: `import { Skeleton } from "@/components/Skeleton";`
  </action>
  <verify>
1. Clear browser cache and reload /course - should see skeleton cards
2. Navigate to a module - should see skeleton layout briefly
3. Skeletons should pulse (animate-pulse from Tailwind)
4. Skeletons should approximate actual content layout
  </verify>
  <done>Loading states show structured skeletons instead of generic text</done>
</task>

</tasks>

<verification>
1. View Transitions: Navigate between Home and Course via BottomNav - pages should crossfade
2. Skeleton loading: Force slow network in DevTools, reload pages - should see pulsing skeletons
3. Reduced motion: With `prefers-reduced-motion: reduce`, transitions should be minimal/instant
4. Fallback: In Safari < 18 or with View Transitions disabled, navigation should still work
</verification>

<success_criteria>
- Page navigation has visible crossfade transition (not instant cut)
- Loading states show skeleton placeholders matching content structure
- Skeletons animate with pulse effect
- All functionality works in browsers without View Transitions API
</success_criteria>

<output>
After completion, create `.planning/phases/05-motion-polish/05-02-SUMMARY.md`
</output>
