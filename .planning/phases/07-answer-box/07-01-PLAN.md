---
phase: 07-answer-box
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - core/tables.py
  - core/assessments.py
  - core/__init__.py
  - alembic/versions/  # new migration file
  - web_api/routes/assessments.py
  - web_frontend/src/types/module.ts
  - web_frontend/src/api/assessments.ts
  - web_frontend/src/hooks/useAutoSave.ts
  - web_frontend/src/components/module/AnswerBox.tsx
  - web_frontend/src/views/Module.tsx
autonomous: true

must_haves:
  truths:
    - "Student sees an answer box with question prompt rendered inline within module content"
    - "Student can type a free-text response into the answer box"
    - "Answer text is preserved continuously — no save button needed, no data loss on refresh"
    - "Student can click Finish to mark an answer as complete"
    - "Answers persist across page refresh — student sees their previous text on return"
    - "Save status indicator shows Saving.../Saved feedback"
  artifacts:
    - path: "web_frontend/src/components/module/AnswerBox.tsx"
      provides: "Answer box component with textarea, auto-save, completion flow"
      min_lines: 80
    - path: "web_frontend/src/hooks/useAutoSave.ts"
      provides: "Debounced auto-save hook with lazy create (POST) then update (PATCH) pattern"
      min_lines: 60
    - path: "web_frontend/src/api/assessments.ts"
      provides: "API client for assessment endpoints (create, update, load responses)"
      min_lines: 40
    - path: "web_api/routes/assessments.py"
      provides: "PATCH /api/assessments/responses/{response_id} endpoint"
      contains: "update_assessment_response"
    - path: "core/assessments.py"
      provides: "update_response function for PATCH operations"
      contains: "update_response"
  key_links:
    - from: "web_frontend/src/components/module/AnswerBox.tsx"
      to: "web_frontend/src/hooks/useAutoSave.ts"
      via: "useAutoSave hook call"
      pattern: "useAutoSave"
    - from: "web_frontend/src/hooks/useAutoSave.ts"
      to: "web_frontend/src/api/assessments.ts"
      via: "createResponse and updateResponse API calls"
      pattern: "createResponse|updateResponse"
    - from: "web_frontend/src/api/assessments.ts"
      to: "/api/assessments/responses"
      via: "fetch calls to backend endpoints"
      pattern: "api/assessments/responses"
    - from: "web_frontend/src/views/Module.tsx"
      to: "web_frontend/src/components/module/AnswerBox.tsx"
      via: "renderSegment case for question type"
      pattern: 'case "question"'
---

<objective>
Build the AnswerBox component with auto-expanding textarea, debounced auto-save via PATCH endpoint, completion flow, and Module.tsx integration so students can type free-text answers that are continuously persisted.

Purpose: This is the core answer input mechanism for the assessment system. Students need to type answers inline within module content, with Google Docs-style auto-save so no work is lost.

Output: Working answer box that renders for `question` segments, auto-saves text to the database, shows save status, supports completion, and loads existing answers on revisit.
</objective>

<execution_context>
@/home/penguin/.claude/get-shit-done/workflows/execute-plan.md
@/home/penguin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-answer-box/07-CONTEXT.md
@.planning/phases/07-answer-box/07-RESEARCH.md
@.planning/phases/06-data-foundation/06-01-SUMMARY.md
@.planning/phases/06-data-foundation/06-02-SUMMARY.md

Key source files to reference:
@core/tables.py (assessment_responses table at line 434)
@core/assessments.py (existing CRUD functions)
@web_api/routes/assessments.py (existing POST/GET endpoints)
@web_frontend/src/types/module.ts (ModuleSegment union — needs QuestionSegment)
@web_frontend/src/api/progress.ts (auth header pattern to follow)
@web_frontend/src/views/Module.tsx (renderSegment switch at line 808)
@web_frontend/src/config.ts (API_URL)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend — Add completed_at column, update_response function, and PATCH endpoint</name>
  <files>
    core/tables.py
    core/assessments.py
    core/__init__.py
    alembic/versions/ (new migration)
    web_api/routes/assessments.py
  </files>
  <action>
    **1. Add `completed_at` column to assessment_responses table in `core/tables.py`:**
    - Add `Column("completed_at", TIMESTAMP(timezone=True), nullable=True)` to the assessment_responses table definition, after the `created_at` column (before the Indexes comment).
    - This timestamp distinguishes finished answers from in-progress drafts. NULL = in progress, non-NULL = completed.

    **2. Generate Alembic migration:**
    - Run `.venv/bin/alembic revision --autogenerate -m "add completed_at to assessment_responses"`
    - Review the generated migration — it should only contain `add_column` for `completed_at`. Remove any spurious operations (e.g., apscheduler_jobs) as was needed in 06-01.
    - Verify the downgrade properly drops the column.

    **3. Add `update_response` function to `core/assessments.py`:**
    ```python
    async def update_response(
        conn: AsyncConnection,
        *,
        response_id: int,
        user_id: int | None = None,
        anonymous_token: UUID | None = None,
        answer_text: str | None = None,
        answer_metadata: dict | None = None,
        completed_at: str | None = None,  # ISO format string or None
    ) -> dict | None:
    ```
    - Build an UPDATE statement for assessment_responses WHERE response_id = given AND (user_id matches OR anonymous_token matches). This ownership check prevents users from editing others' responses.
    - Only include non-None fields in the SET clause (partial update).
    - If `completed_at` is provided as an ISO string, parse it with `datetime.fromisoformat()`. If provided as empty string or "null", set the column to NULL (for reopening in lesson mode).
    - Use `.returning(assessment_responses)` to return the updated row.
    - Return `dict(row._mapping)` if row found, `None` if no matching row.
    - Follow the same patterns as existing functions (SQLAlchemy Core, async, type hints).

    **4. Export `update_response` from `core/__init__.py`:**
    - Add `update_response` to the imports from `core.assessments`.

    **5. Add PATCH endpoint to `web_api/routes/assessments.py`:**
    - Add `UpdateResponseRequest` Pydantic model:
      ```python
      class UpdateResponseRequest(BaseModel):
          answer_text: str | None = None
          answer_metadata: dict | None = None
          completed_at: str | None = None  # ISO format or empty string to clear
      ```
    - Add PATCH endpoint at `/responses/{response_id}`:
      ```python
      @router.patch("/responses/{response_id}", response_model=SubmitResponseResponse)
      async def update_assessment_response(
          response_id: int,
          body: UpdateResponseRequest,
          auth: tuple = Depends(get_user_or_anonymous),
      ):
      ```
    - Import `update_response` from `core.assessments`.
    - Use `get_transaction()` for the database operation (writes need transactions).
    - Return 404 if `update_response` returns None.
    - Format `created_at` as ISO string (same pattern as existing submit endpoint).

    **6. Update `ResponseItem` model** to include `completed_at: str | None` field, and update `_format_response_items` to include it.

    **7. Relax the POST endpoint's answer_text validation**: Currently `submit_assessment_response` rejects empty `answer_text`. For lazy-create on first keystroke, the initial POST may have very short text. Change validation to allow any non-None text (remove the `.strip()` emptiness check, but keep `.strip()` on the stored value). Actually, better: keep it as-is since the first keystroke will produce at least one character. No change needed here.

    **Run checks:**
    - `ruff check .` and `ruff format --check .` must pass
    - `pytest` must pass (existing tests should still work since we're only adding, not changing existing behavior)
  </action>
  <verify>
    - `ruff check . && ruff format --check .` passes clean
    - `pytest` passes (all existing tests)
    - Migration file exists and contains only `add_column` for `completed_at`
    - `grep -n "update_response" core/assessments.py` shows the new function
    - `grep -n "patch" web_api/routes/assessments.py` shows the new endpoint
    - `grep -n "completed_at" core/tables.py` shows the new column
  </verify>
  <done>
    PATCH /api/assessments/responses/{response_id} endpoint exists and can update answer_text, answer_metadata, and completed_at. The update_response core function performs ownership-checked partial updates. Migration adds completed_at column. ResponseItem includes completed_at in GET responses.
  </done>
</task>

<task type="auto">
  <name>Task 2: Frontend — QuestionSegment type, API client, useAutoSave hook, AnswerBox component, Module.tsx integration</name>
  <files>
    web_frontend/src/types/module.ts
    web_frontend/src/api/assessments.ts
    web_frontend/src/hooks/useAutoSave.ts
    web_frontend/src/components/module/AnswerBox.tsx
    web_frontend/src/views/Module.tsx
  </files>
  <action>
    **1. Add QuestionSegment type to `web_frontend/src/types/module.ts`:**
    ```typescript
    export type QuestionSegment = {
      type: "question";
      userInstruction: string;
      assessmentPrompt?: string;
      maxTime?: string;
      maxChars?: number;
      enforceVoice?: boolean;
      optional?: boolean;
    };
    ```
    - Add `QuestionSegment` to the `ModuleSegment` union type.
    - Also add a `TestSection` type for completeness (Phase 8 will use it, but the content processor already emits type "test"):
    ```typescript
    export type TestSection = {
      type: "test";
      contentId: string | null;
      learningOutcomeId: string | null;
      learningOutcomeName: string | null;
      meta: { title: string | null };
      segments: ModuleSegment[];
      optional: boolean;
    };
    ```
    - Add `TestSection` to the `ModuleSection` union.

    **2. Create `web_frontend/src/api/assessments.ts`:**
    Follow the pattern from `api/progress.ts` — use `fetchWithRefresh`, `getAnonymousToken`, `API_URL`.

    Functions needed:
    - `createResponse(params)`: POST to `/api/assessments/responses` — creates a new response record. Params: `{ questionId, moduleSlug, learningOutcomeId?, contentId?, answerText, answerMetadata? }`. Returns `{ response_id, created_at }`.
    - `updateResponse(responseId, params)`: PATCH to `/api/assessments/responses/{responseId}` — updates an existing response. Params: `{ answerText?, answerMetadata?, completedAt? }`. Returns `{ response_id, created_at }`.
    - `getResponses(params)`: GET from `/api/assessments/responses` with query params `module_slug` and `question_id`. Returns `{ responses: ResponseItem[] }`.

    Each function should:
    - Accept an `isAuthenticated: boolean` parameter
    - Use `getAuthHeaders(isAuthenticated)` helper (same pattern as progress.ts)
    - Include `credentials: "include"` for cookie-based auth
    - Set `Content-Type: application/json` for POST/PATCH
    - Throw on non-ok response

    **3. Create `web_frontend/src/hooks/useAutoSave.ts`:**
    Custom hook implementing the lazy-create + debounced-update pattern.

    Interface:
    ```typescript
    interface UseAutoSaveOptions {
      questionId: string;
      moduleSlug: string;
      learningOutcomeId?: string | null;
      contentId?: string | null;
      isAuthenticated: boolean;
      debounceMs?: number; // default 2500
    }

    interface UseAutoSaveReturn {
      text: string;
      setText: (text: string) => void;
      setMetadata: (metadata: Record of string to unknown) => void; // merge keys into answer_metadata (e.g., { voice_used: true })
      saveStatus: 'idle' | 'saving' | 'saved' | 'error';
      isCompleted: boolean;
      markComplete: () => Promise (async, resolves void);
      reopenAnswer: () => Promise (async, resolves void);
      responseId: number | null;
      isLoading: boolean; // true while loading existing answer
    }
    ```

    Implementation details:
    - **On mount:** Call `getResponses({ moduleSlug, questionId, isAuthenticated })` to load existing answers. Find the most recent response. If it has no `completed_at`, resume editing (set responseId, set text). If all are completed, set `isCompleted` state (in lesson mode, user can reopen; in test mode Phase 8 will lock).
    - **On text change via setText:** Store in state, start debounce timer. If no responseId yet (first keystroke), queue a POST. If responseId exists, queue a PATCH.
    - **Debounce logic:** Use `useRef` for timer. On each setText call, clear existing timer, set new one for `debounceMs`. When timer fires, call `flushSave()`.
    - **flushSave():** The core save function. Uses a `savingRef` to prevent concurrent saves. If `responseId` is null, POST to create (sets responseId from response). If `responseId` exists, PATCH to update. Updates `saveStatus` state.
    - **Save status indicator timing:** Only show "Saving..." if save takes >300ms (use a delayed state transition). Show "Saved" for 2 seconds then fade to idle.
    - **On unmount:** `useEffect` cleanup must flush any pending save synchronously. Use `navigator.sendBeacon` as fallback or fire-and-forget the pending PATCH (since the component is unmounting, we can't await).
    - **markComplete():** Flush any pending text save, then PATCH with `completed_at` set to `new Date().toISOString()`. Set `isCompleted` state.
    - **reopenAnswer():** Create a new response via POST (new attempt), reset `isCompleted`, set new responseId. This allows re-answering in lesson mode.
    - **setMetadata(metadata):** Merges keys into a `metadataRef` (a useRef holding a Record of string to unknown). On each save (both POST and PATCH), include the current metadata ref value as `answer_metadata`. This lets consumers (e.g., AnswerBox voice input) flag `{ voice_used: true }` without triggering an immediate save — the metadata gets included in the next debounced save.
    - **Race condition prevention:** Use a ref (`latestTextRef`) to always send the latest text. Use a `pendingSaveRef` boolean to queue at most one pending save while a save is in flight.
    - **Error handling:** On save failure, set saveStatus to 'error'. Don't lose the text — keep it in state. The next debounce will retry.

    **4. Create `web_frontend/src/components/module/AnswerBox.tsx`:**
    A minimal, inline answer box component.

    Props:
    ```typescript
    interface AnswerBoxProps {
      segment: QuestionSegment;
      moduleSlug: string;
      sectionIndex: number;
      segmentIndex: number;
      learningOutcomeId?: string | null;
      contentId?: string | null;
      isAuthenticated: boolean;
    }
    ```

    Structure:
    - Question prompt: Display `segment.userInstruction` as a paragraph above the textarea. Style with slightly larger/bolder text to distinguish from body text.
    - Auto-expanding textarea: Use the same pattern from NarrativeChatSection (set height to auto, then scrollHeight). But do NOT cap maxHeight — let the textarea grow with content (students write long answers). Add a generous minHeight (e.g., 120px / ~4 lines).
    - Character count: If `segment.maxChars` is set, show `{text.length}/{segment.maxChars}` below the textarea. If over limit, show in red/warning color. Enforce maxLength on the textarea.
    - Save status indicator: Small text below textarea, left-aligned. "Saving..." in muted color, "Saved" with a subtle checkmark, fades away after 2s. "Error saving" in red if error.
    - Finish button: Right-aligned below textarea. Text: "Finish" when active, "Completed" when done. Disabled when text is empty or already completed. Use a subtle style (not primary button — this isn't a heavy action). When clicked, calls `markComplete()`.
    - Completed state: Show the answer text as non-editable (textarea with `disabled` or replace with a styled div). Show a "Completed" badge. In lesson context (not test), show a small "Edit" or "Answer again" link that calls `reopenAnswer()`.
    - Loading state: While `isLoading` is true, show a subtle skeleton or placeholder in the textarea area.
    - Generate questionId deterministically: `${moduleSlug}:${sectionIndex}:${segmentIndex}` — stable as long as content structure doesn't change.

    Styling guidelines (from CONTEXT decisions):
    - Light, inline style — NOT a heavy card. No card shadow, no thick borders.
    - Subtle border on the textarea (e.g., `border-gray-200` or `border-stone-200`).
    - Use the same `max-w-content` wrapper as other content for consistent width.
    - Rounded corners on textarea (`rounded-lg`).
    - Focus ring on textarea (`focus:ring-2 focus:ring-blue-500` or matching site accent).
    - `py-6` vertical spacing to separate from surrounding content.
    - Use Tailwind's `transition-opacity` for save indicator fade.

    **5. Integrate into `web_frontend/src/views/Module.tsx`:**
    - Import `AnswerBox` component.
    - Import `QuestionSegment` type (if needed for type narrowing).
    - Add a `case "question":` to the `renderSegment` switch (after the `case "chat":` block):
      ```tsx
      case "question":
        return (
          <AnswerBox
            key={`question-${keyPrefix}`}
            segment={segment}
            moduleSlug={module.slug}
            sectionIndex={sectionIndex}
            segmentIndex={segmentIndex}
            learningOutcomeId={
              "learningOutcomeId" in section ? section.learningOutcomeId : null
            }
            contentId={"contentId" in section ? section.contentId : null}
            isAuthenticated={isAuthenticated}
          />
        );
      ```
    - The `isAuthenticated` variable already exists in Module.tsx (from `useAuth()`).

    **Run checks:**
    - `cd web_frontend && npm run lint` must pass
    - `cd web_frontend && npm run build` must pass (TypeScript type check + Vite build)
  </action>
  <verify>
    - `cd web_frontend && npm run lint` passes clean
    - `cd web_frontend && npm run build` passes clean
    - `grep -n "QuestionSegment" web_frontend/src/types/module.ts` shows the new type
    - `grep -n 'case "question"' web_frontend/src/views/Module.tsx` shows the integration
    - Files exist: `web_frontend/src/api/assessments.ts`, `web_frontend/src/hooks/useAutoSave.ts`, `web_frontend/src/components/module/AnswerBox.tsx`
  </verify>
  <done>
    AnswerBox component renders inline for question segments in module content. Auto-expanding textarea accepts free-text input. useAutoSave hook creates response on first keystroke (POST), then debounces PATCH updates every 2.5s. Save status indicator shows feedback. Finish button marks answer complete. Existing answers load on mount (no data loss on refresh). Module.tsx renders AnswerBox for question segment type.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `ruff check . && ruff format --check .` passes (Python)
2. `pytest` passes (all existing + any new tests)
3. `cd web_frontend && npm run lint && npm run build` passes (TypeScript + build)
4. PATCH endpoint exists at `/api/assessments/responses/{response_id}`
5. AnswerBox component exists and is wired into Module.tsx renderSegment
6. QuestionSegment type exists in module.ts and is part of ModuleSegment union
7. useAutoSave hook implements lazy-create + debounced-update pattern
8. API client `assessments.ts` has createResponse, updateResponse, getResponses functions
</verification>

<success_criteria>
- A question segment in module content renders an answer box with the question prompt
- Typing into the answer box auto-saves after ~2.5s debounce
- The first keystroke creates a new response record (POST), subsequent saves update it (PATCH)
- Save status indicator shows Saving.../Saved feedback
- Clicking Finish marks the answer as complete (sets completed_at)
- Refreshing the page loads the existing answer text
- Character count shows when maxChars is configured
- The answer box has minimal, inline styling that blends with module content
</success_criteria>

<output>
After completion, create `.planning/phases/07-answer-box/07-01-SUMMARY.md`
</output>
