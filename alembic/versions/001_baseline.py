"""Baseline schema - squashed from all previous migrations.

Revision ID: 001
Revises:
Create Date: 2026-02-05

This is the baseline migration created by squashing all previous migrations.
It creates the complete current schema with explicit DDL (not metadata.create_all).

For existing databases (staging, production), run: alembic stamp 001
For new databases, this creates all tables from scratch.
"""

from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = "001"
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table(
        "cohorts",
        sa.Column("cohort_id", sa.Integer(), autoincrement=True, nullable=False),
        sa.Column("cohort_name", sa.Text(), nullable=True),
        sa.Column("course_slug", sa.Text(), nullable=False),
        sa.Column("cohort_start_date", sa.Date(), nullable=False),
        sa.Column("duration_days", sa.Integer(), nullable=False),
        sa.Column("number_of_group_meetings", sa.Integer(), nullable=False),
        sa.Column("discord_category_id", sa.Text(), nullable=True),
        sa.Column("discord_cohort_channel_id", sa.Text(), nullable=True),
        sa.Column(
            "status",
            sa.Enum("active", "completed", "cancelled", name="cohort_status"),
            server_default="active",
            nullable=True,
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            nullable=True,
        ),
        sa.PrimaryKeyConstraint("cohort_id", name=op.f("pk_cohorts")),
    )
    op.create_index("idx_cohorts_course_slug", "cohorts", ["course_slug"], unique=False)
    op.create_index(
        "idx_cohorts_start_date", "cohorts", ["cohort_start_date"], unique=False
    )
    op.create_table(
        "users",
        sa.Column("user_id", sa.Integer(), autoincrement=True, nullable=False),
        sa.Column("discord_id", sa.Text(), nullable=True),
        sa.Column("discord_username", sa.Text(), nullable=True),
        sa.Column("discord_avatar", sa.Text(), nullable=True),
        sa.Column("nickname", sa.Text(), nullable=True),
        sa.Column("email", sa.Text(), nullable=True),
        sa.Column(
            "email_verified_at", postgresql.TIMESTAMP(timezone=True), nullable=True
        ),
        sa.Column("last_active_at", postgresql.TIMESTAMP(timezone=True), nullable=True),
        sa.Column("timezone", sa.Text(), nullable=True),
        sa.Column("availability_local", sa.Text(), nullable=True),
        sa.Column("if_needed_availability_local", sa.Text(), nullable=True),
        sa.Column(
            "availability_last_updated_at",
            postgresql.TIMESTAMP(timezone=True),
            nullable=True,
        ),
        sa.Column(
            "email_notifications_enabled",
            sa.Boolean(),
            server_default="true",
            nullable=True,
        ),
        sa.Column(
            "dm_notifications_enabled",
            sa.Boolean(),
            server_default="true",
            nullable=True,
        ),
        sa.Column("is_admin", sa.Boolean(), server_default="false", nullable=True),
        sa.Column(
            "tos_accepted_at", postgresql.TIMESTAMP(timezone=True), nullable=True
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            nullable=True,
        ),
        sa.Column("deleted_at", postgresql.TIMESTAMP(timezone=True), nullable=True),
        sa.PrimaryKeyConstraint("user_id", name=op.f("pk_users")),
    )
    op.create_index("idx_users_discord_id", "users", ["discord_id"], unique=False)
    op.create_index("idx_users_email", "users", ["email"], unique=False)
    op.create_table(
        "auth_codes",
        sa.Column("code_id", sa.Integer(), autoincrement=True, nullable=False),
        sa.Column("code", sa.Text(), nullable=False),
        sa.Column("user_id", sa.Integer(), nullable=False),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            nullable=True,
        ),
        sa.Column("expires_at", postgresql.TIMESTAMP(timezone=True), nullable=False),
        sa.Column("used_at", postgresql.TIMESTAMP(timezone=True), nullable=True),
        sa.Column("discord_id", sa.Text(), nullable=True),
        sa.ForeignKeyConstraint(
            ["user_id"],
            ["users.user_id"],
            name=op.f("fk_auth_codes_user_id_users"),
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("code_id", name=op.f("pk_auth_codes")),
        sa.UniqueConstraint("code", name=op.f("uq_auth_codes_code")),
    )
    op.create_index("idx_auth_codes_code", "auth_codes", ["code"], unique=False)
    op.create_index("idx_auth_codes_user_id", "auth_codes", ["user_id"], unique=False)
    op.create_table(
        "chat_sessions",
        sa.Column("session_id", sa.Integer(), autoincrement=True, nullable=False),
        sa.Column("anonymous_token", sa.UUID(), nullable=True),
        sa.Column("user_id", sa.Integer(), nullable=True),
        sa.Column("content_id", sa.UUID(), nullable=True),
        sa.Column("content_type", sa.Text(), nullable=True),
        sa.Column(
            "messages",
            postgresql.JSONB(astext_type=sa.Text()),
            server_default="[]",
            nullable=False,
        ),
        sa.Column(
            "started_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.Column(
            "last_active_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.Column("archived_at", sa.DateTime(timezone=True), nullable=True),
        sa.CheckConstraint(
            "content_type IS NULL OR content_type IN ('module', 'lo', 'lens', 'test')",
            name=op.f("ck_chat_sessions_valid_chat_content_type"),
        ),
        sa.ForeignKeyConstraint(
            ["user_id"],
            ["users.user_id"],
            name=op.f("fk_chat_sessions_user_id_users"),
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("session_id", name=op.f("pk_chat_sessions")),
    )
    op.create_index(
        "idx_chat_sessions_token", "chat_sessions", ["anonymous_token"], unique=False
    )
    op.create_index(
        "idx_chat_sessions_unique_anon_active",
        "chat_sessions",
        ["anonymous_token", "content_id"],
        unique=True,
        postgresql_where=sa.text("anonymous_token IS NOT NULL AND archived_at IS NULL"),
    )
    op.create_index(
        "idx_chat_sessions_unique_user_active",
        "chat_sessions",
        ["user_id", "content_id"],
        unique=True,
        postgresql_where=sa.text("user_id IS NOT NULL AND archived_at IS NULL"),
    )
    op.create_index(
        "idx_chat_sessions_user_content",
        "chat_sessions",
        ["user_id", "content_id", "archived_at"],
        unique=False,
    )
    op.create_table(
        "facilitators",
        sa.Column("facilitator_id", sa.Integer(), autoincrement=True, nullable=False),
        sa.Column("user_id", sa.Integer(), nullable=False),
        sa.Column("max_active_groups", sa.Integer(), server_default="2", nullable=True),
        sa.Column("certified_at", postgresql.TIMESTAMP(timezone=True), nullable=True),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            nullable=True,
        ),
        sa.ForeignKeyConstraint(
            ["user_id"],
            ["users.user_id"],
            name=op.f("fk_facilitators_user_id_users"),
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("facilitator_id", name=op.f("pk_facilitators")),
    )
    op.create_index(
        "idx_facilitators_user_id", "facilitators", ["user_id"], unique=False
    )
    op.create_table(
        "groups",
        sa.Column("group_id", sa.Integer(), autoincrement=True, nullable=False),
        sa.Column("group_name", sa.Text(), nullable=False),
        sa.Column("cohort_id", sa.Integer(), nullable=False),
        sa.Column("course_slug_override", sa.Text(), nullable=True),
        sa.Column("discord_category_id", sa.Text(), nullable=True),
        sa.Column("discord_text_channel_id", sa.Text(), nullable=True),
        sa.Column("discord_voice_channel_id", sa.Text(), nullable=True),
        sa.Column("discord_role_id", sa.Text(), nullable=True),
        sa.Column("recurring_meeting_time_utc", sa.Text(), nullable=True),
        sa.Column(
            "status",
            sa.Enum(
                "preview",
                "active",
                "completed",
                "merged",
                "cancelled",
                name="group_status",
            ),
            server_default="preview",
            nullable=True,
        ),
        sa.Column("start_date", sa.Date(), nullable=True),
        sa.Column("expected_end_date", sa.Date(), nullable=True),
        sa.Column("actual_end_date", sa.Date(), nullable=True),
        sa.Column(
            "discord_channel_archived_at",
            postgresql.TIMESTAMP(timezone=True),
            nullable=True,
        ),
        sa.Column("gcal_recurring_event_id", sa.Text(), nullable=True),
        sa.Column(
            "calendar_invite_sent_at",
            postgresql.TIMESTAMP(timezone=True),
            nullable=True,
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            nullable=True,
        ),
        sa.ForeignKeyConstraint(
            ["cohort_id"],
            ["cohorts.cohort_id"],
            name=op.f("fk_groups_cohort_id_cohorts"),
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("group_id", name=op.f("pk_groups")),
    )
    op.create_index("idx_groups_cohort_id", "groups", ["cohort_id"], unique=False)
    op.create_table(
        "notification_log",
        sa.Column("log_id", sa.Integer(), autoincrement=True, nullable=False),
        sa.Column("user_id", sa.Integer(), nullable=True),
        sa.Column("channel_id", sa.Text(), nullable=True),
        sa.Column("message_type", sa.Text(), nullable=False),
        sa.Column("channel", sa.Text(), nullable=False),
        sa.Column("status", sa.Text(), nullable=False),
        sa.Column("error_message", sa.Text(), nullable=True),
        sa.Column(
            "sent_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            nullable=True,
        ),
        sa.Column(
            "reference_type",
            sa.Enum(
                "group_id",
                "meeting_id",
                "cohort_id",
                "user_id",
                name="notification_reference_type",
            ),
            nullable=True,
        ),
        sa.Column("reference_id", sa.Integer(), nullable=True),
        sa.ForeignKeyConstraint(
            ["user_id"],
            ["users.user_id"],
            name=op.f("fk_notification_log_user_id_users"),
            ondelete="SET NULL",
        ),
        sa.PrimaryKeyConstraint("log_id", name=op.f("pk_notification_log")),
    )
    op.create_index(
        "idx_notification_log_dedup",
        "notification_log",
        ["user_id", "message_type", "reference_type", "reference_id"],
        unique=False,
    )
    op.create_index(
        "idx_notification_log_sent_at", "notification_log", ["sent_at"], unique=False
    )
    op.create_index(
        "idx_notification_log_user_id", "notification_log", ["user_id"], unique=False
    )
    op.create_table(
        "signups",
        sa.Column("signup_id", sa.Integer(), autoincrement=True, nullable=False),
        sa.Column("user_id", sa.Integer(), nullable=False),
        sa.Column("cohort_id", sa.Integer(), nullable=False),
        sa.Column(
            "role",
            sa.Enum("participant", "facilitator", name="cohort_role"),
            nullable=False,
        ),
        sa.Column(
            "ungroupable_reason",
            sa.Enum(
                "no_availability",
                "no_overlap_with_others",
                "no_facilitator_overlap",
                "facilitator_capacity",
                "insufficient_group_size",
                name="ungroupable_reason",
            ),
            nullable=True,
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            nullable=True,
        ),
        sa.ForeignKeyConstraint(
            ["cohort_id"],
            ["cohorts.cohort_id"],
            name=op.f("fk_signups_cohort_id_cohorts"),
            ondelete="CASCADE",
        ),
        sa.ForeignKeyConstraint(
            ["user_id"],
            ["users.user_id"],
            name=op.f("fk_signups_user_id_users"),
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("signup_id", name=op.f("pk_signups")),
    )
    op.create_index("idx_signups_cohort_id", "signups", ["cohort_id"], unique=False)
    op.create_index("idx_signups_user_id", "signups", ["user_id"], unique=False)
    op.create_table(
        "user_content_progress",
        sa.Column("id", sa.Integer(), autoincrement=True, nullable=False),
        sa.Column("anonymous_token", sa.UUID(), nullable=True),
        sa.Column("user_id", sa.Integer(), nullable=True),
        sa.Column("content_id", sa.UUID(), nullable=False),
        sa.Column("content_type", sa.Text(), nullable=False),
        sa.Column("content_title", sa.Text(), nullable=False),
        sa.Column(
            "started_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.Column(
            "time_to_complete_s", sa.Integer(), server_default="0", nullable=False
        ),
        sa.Column(
            "total_time_spent_s", sa.Integer(), server_default="0", nullable=False
        ),
        sa.Column("completed_at", sa.DateTime(timezone=True), nullable=True),
        sa.CheckConstraint(
            "content_type IN ('module', 'lo', 'lens', 'test')",
            name=op.f("ck_user_content_progress_valid_content_type"),
        ),
        sa.ForeignKeyConstraint(
            ["user_id"],
            ["users.user_id"],
            name=op.f("fk_user_content_progress_user_id_users"),
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("id", name=op.f("pk_user_content_progress")),
    )
    op.create_index(
        "idx_user_content_progress_anon",
        "user_content_progress",
        ["anonymous_token", "content_id"],
        unique=True,
        postgresql_where=sa.text("anonymous_token IS NOT NULL"),
    )
    op.create_index(
        "idx_user_content_progress_token",
        "user_content_progress",
        ["anonymous_token"],
        unique=False,
        postgresql_where=sa.text("anonymous_token IS NOT NULL"),
    )
    op.create_index(
        "idx_user_content_progress_user",
        "user_content_progress",
        ["user_id", "content_id"],
        unique=True,
        postgresql_where=sa.text("user_id IS NOT NULL"),
    )
    op.create_table(
        "groups_users",
        sa.Column("group_user_id", sa.Integer(), autoincrement=True, nullable=False),
        sa.Column("user_id", sa.Integer(), nullable=False),
        sa.Column("group_id", sa.Integer(), nullable=False),
        sa.Column(
            "role",
            sa.Enum("participant", "facilitator", name="group_user_role"),
            nullable=False,
        ),
        sa.Column(
            "status",
            sa.Enum(
                "active", "dropped", "completed", "removed", name="group_user_status"
            ),
            server_default="active",
            nullable=True,
        ),
        sa.Column(
            "joined_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            nullable=True,
        ),
        sa.Column("left_at", postgresql.TIMESTAMP(timezone=True), nullable=True),
        sa.Column("completed_at", postgresql.TIMESTAMP(timezone=True), nullable=True),
        sa.Column("reason_for_leaving", sa.Text(), nullable=True),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            nullable=True,
        ),
        sa.ForeignKeyConstraint(
            ["group_id"],
            ["groups.group_id"],
            name=op.f("fk_groups_users_group_id_groups"),
            ondelete="CASCADE",
        ),
        sa.ForeignKeyConstraint(
            ["user_id"],
            ["users.user_id"],
            name=op.f("fk_groups_users_user_id_users"),
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("group_user_id", name=op.f("pk_groups_users")),
    )
    op.create_index(
        "idx_groups_users_group_id", "groups_users", ["group_id"], unique=False
    )
    op.create_index(
        "idx_groups_users_user_id", "groups_users", ["user_id"], unique=False
    )
    op.create_table(
        "meetings",
        sa.Column("meeting_id", sa.Integer(), autoincrement=True, nullable=False),
        sa.Column("group_id", sa.Integer(), nullable=True),
        sa.Column("cohort_id", sa.Integer(), nullable=True),
        sa.Column("scheduled_at", postgresql.TIMESTAMP(timezone=True), nullable=False),
        sa.Column("meeting_number", sa.Integer(), nullable=True),
        sa.Column("discord_event_id", sa.Text(), nullable=True),
        sa.Column("discord_voice_channel_id", sa.Text(), nullable=True),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            nullable=True,
        ),
        sa.ForeignKeyConstraint(
            ["cohort_id"],
            ["cohorts.cohort_id"],
            name=op.f("fk_meetings_cohort_id_cohorts"),
            ondelete="CASCADE",
        ),
        sa.ForeignKeyConstraint(
            ["group_id"],
            ["groups.group_id"],
            name=op.f("fk_meetings_group_id_groups"),
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("meeting_id", name=op.f("pk_meetings")),
    )
    op.create_index("idx_meetings_cohort_id", "meetings", ["cohort_id"], unique=False)
    op.create_index("idx_meetings_group_id", "meetings", ["group_id"], unique=False)
    op.create_index(
        "idx_meetings_scheduled_at", "meetings", ["scheduled_at"], unique=False
    )
    op.create_table(
        "attendances",
        sa.Column("attendance_id", sa.Integer(), autoincrement=True, nullable=False),
        sa.Column("meeting_id", sa.Integer(), nullable=False),
        sa.Column("user_id", sa.Integer(), nullable=False),
        sa.Column(
            "rsvp_status",
            sa.Enum(
                "pending", "attending", "not_attending", "tentative", name="rsvp_status"
            ),
            server_default="pending",
            nullable=True,
        ),
        sa.Column("rsvp_at", postgresql.TIMESTAMP(timezone=True), nullable=True),
        sa.Column("checked_in_at", postgresql.TIMESTAMP(timezone=True), nullable=True),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            nullable=True,
        ),
        sa.ForeignKeyConstraint(
            ["meeting_id"],
            ["meetings.meeting_id"],
            name=op.f("fk_attendances_meeting_id_meetings"),
            ondelete="CASCADE",
        ),
        sa.ForeignKeyConstraint(
            ["user_id"],
            ["users.user_id"],
            name=op.f("fk_attendances_user_id_users"),
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("attendance_id", name=op.f("pk_attendances")),
    )
    op.create_index(
        "idx_attendances_meeting_id", "attendances", ["meeting_id"], unique=False
    )
    op.create_index("idx_attendances_user_id", "attendances", ["user_id"], unique=False)

    # Create signup_overview view (for admin queries)
    op.execute("""
        CREATE VIEW signup_overview AS
        SELECT
            s.signup_id,
            s.user_id,
            s.cohort_id,
            s.role AS cohort_role,
            s.ungroupable_reason,
            u.nickname,
            u.timezone,
            u.availability_local,
            g.group_id,
            g.recurring_meeting_time_utc
        FROM signups s
        LEFT JOIN users u
            ON s.user_id = u.user_id
        LEFT JOIN groups_users gu
            ON s.user_id = gu.user_id
            AND gu.status = 'active'
        LEFT JOIN groups g
            ON gu.group_id = g.group_id
            AND g.cohort_id = s.cohort_id
    """)
    # ### end Alembic commands ###


def downgrade() -> None:
    # Drop view first (depends on tables)
    op.execute("DROP VIEW IF EXISTS signup_overview")

    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index("idx_attendances_user_id", table_name="attendances")
    op.drop_index("idx_attendances_meeting_id", table_name="attendances")
    op.drop_table("attendances")
    op.drop_index("idx_meetings_scheduled_at", table_name="meetings")
    op.drop_index("idx_meetings_group_id", table_name="meetings")
    op.drop_index("idx_meetings_cohort_id", table_name="meetings")
    op.drop_table("meetings")
    op.drop_index("idx_groups_users_user_id", table_name="groups_users")
    op.drop_index("idx_groups_users_group_id", table_name="groups_users")
    op.drop_table("groups_users")
    op.drop_index(
        "idx_user_content_progress_user",
        table_name="user_content_progress",
        postgresql_where=sa.text("user_id IS NOT NULL"),
    )
    op.drop_index(
        "idx_user_content_progress_token",
        table_name="user_content_progress",
        postgresql_where=sa.text("anonymous_token IS NOT NULL"),
    )
    op.drop_index(
        "idx_user_content_progress_anon",
        table_name="user_content_progress",
        postgresql_where=sa.text("anonymous_token IS NOT NULL"),
    )
    op.drop_table("user_content_progress")
    op.drop_index("idx_signups_user_id", table_name="signups")
    op.drop_index("idx_signups_cohort_id", table_name="signups")
    op.drop_table("signups")
    op.drop_index("idx_notification_log_user_id", table_name="notification_log")
    op.drop_index("idx_notification_log_sent_at", table_name="notification_log")
    op.drop_index("idx_notification_log_dedup", table_name="notification_log")
    op.drop_table("notification_log")
    op.drop_index("idx_groups_cohort_id", table_name="groups")
    op.drop_table("groups")
    op.drop_index("idx_facilitators_user_id", table_name="facilitators")
    op.drop_table("facilitators")
    op.drop_index("idx_chat_sessions_user_content", table_name="chat_sessions")
    op.drop_index(
        "idx_chat_sessions_unique_user_active",
        table_name="chat_sessions",
        postgresql_where=sa.text("user_id IS NOT NULL AND archived_at IS NULL"),
    )
    op.drop_index(
        "idx_chat_sessions_unique_anon_active",
        table_name="chat_sessions",
        postgresql_where=sa.text("anonymous_token IS NOT NULL AND archived_at IS NULL"),
    )
    op.drop_index("idx_chat_sessions_token", table_name="chat_sessions")
    op.drop_table("chat_sessions")
    op.drop_index("idx_auth_codes_user_id", table_name="auth_codes")
    op.drop_index("idx_auth_codes_code", table_name="auth_codes")
    op.drop_table("auth_codes")
    op.drop_index("idx_users_email", table_name="users")
    op.drop_index("idx_users_discord_id", table_name="users")
    op.drop_table("users")
    op.drop_index("idx_cohorts_start_date", table_name="cohorts")
    op.drop_index("idx_cohorts_course_slug", table_name="cohorts")
    op.drop_table("cohorts")
    # ### end Alembic commands ###
